<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ðŸŒ¹</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: black;
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      overflow: hidden;
    }
    canvas {
      display: block;
      width: 100vw;
      height: 100vh;
      background: black;
    }
    .message {
      position: absolute;
      bottom: 10%;
      font-size: 2.5rem;
      color: #fff;
      text-align: center;
      text-shadow: 2px 2px 8px rgba(0,0,0,0.8);
      opacity: 0;
      transition: opacity 2s ease-in-out;
    }
    @media (max-width: 600px) {
      .message { font-size: 1.8rem; padding: 0 20px; }
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <div class="message" id="message">PerdÃ³n, no querÃ­a hacerlo ðŸ¥º</div>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const message = document.getElementById('message');

    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    // URL del JSON en GitHub Pages
    const jsonURL = "https://josedavidbarreraortiz-ux.github.io/flor/rosas.json";

    fetch(jsonURL)
      .then(res => {
        if (!res.ok) throw new Error("No se pudo cargar el JSON");
        return res.json();
      })
      .then(regions => animateDrawing(regions))
      .catch(err => alert("Error cargando JSON: " + err.message));

    function animateDrawing(regions) {
      // Calcular lÃ­mites para centrar
      const all_points = [];
      for (let r of regions) {
        for (let p of r.contour) {
          all_points.push([p[0], p[1]]);
        }
      }

      const min_x = Math.min(...all_points.map(p => p[0]));
      const max_x = Math.max(...all_points.map(p => p[0]));
      const min_y = Math.min(...all_points.map(p => p[1]));
      const max_y = Math.max(...all_points.map(p => p[1]));

      const width = max_x - min_x;
      const height = max_y - min_y;
      const scale = Math.min((canvas.width * 0.8) / width, (canvas.height * 0.8) / height);
      const center_x = (min_x + max_x) / 2;
      const center_y = (min_y + max_y) / 2;

      // Preparar lista de segmentos a dibujar
      const segments = [];
      for (let region of regions) {
        const color = `rgb(${Math.floor(region.color[0])}, ${Math.floor(region.color[1])}, ${Math.floor(region.color[2])})`;
        const points = region.contour.map(p => [
          (p[0] - center_x) * scale + canvas.width / 2,
          (center_y - p[1]) * scale + canvas.height / 2
        ]);

        for (let i = 0; i < points.length; i++) {
          const p1 = points[i];
          const p2 = points[(i + 1) % points.length];
          segments.push({ p1, p2, color });
        }
      }

      // AnimaciÃ³n progresiva
      let index = 0;
      function drawStep() {
        if (index < segments.length) {
          const seg = segments[index];
          ctx.strokeStyle = seg.color;
          ctx.beginPath();
          ctx.moveTo(seg.p1[0], seg.p1[1]);
          ctx.lineTo(seg.p2[0], seg.p2[1]);
          ctx.stroke();
          index++;
          requestAnimationFrame(drawStep);
        } else {
          // Mostrar mensaje al final
          setTimeout(() => {
            message.style.opacity = 1;
          }, 500);
        }
      }

      drawStep();
    }
  </script>
</body>
</html>
